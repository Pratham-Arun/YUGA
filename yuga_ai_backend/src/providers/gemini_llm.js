const { GoogleGenerativeAI } = require("@google/generative-ai");

class GeminiLLM {
    constructor(apiKey) {
        if (!apiKey) {
            console.error("[GeminiLLM] Error: GOOGLE_API_KEY is missing!");
            throw new Error("GOOGLE_API_KEY is required for GeminiLLM.");
        }
        this.genAI = new GoogleGenerativeAI(apiKey);
        this.model = this.genAI.getGenerativeModel({ model: "gemini-2.5-flash" });
        this.transcribeModel = this.genAI.getGenerativeModel({ model: "gemini-2.5-flash" }); // Flash 2.5 is multimodal
    }

    async generateCode(prompt, context = "") {
        try {
            const systemPrompt = `You are an expert Godot 4 (GDScript) programmer. Current Mode: Code Generation.
            Rules:
            1. Return ONLY valid GDScript code.
            2. Do not include markdown ticks (like \`\`\`gdscript).
            3. Do not add explanations unless they are comments in the code.
            4. Use the provided context if relevant: ${context}
            `;

            const fullPrompt = systemPrompt + "\nUser: " + prompt;

            const result = await this.model.generateContent(fullPrompt);
            const response = await result.response;
            let text = response.text();

            // Clean up markdown if Gemini adds it despite instructions
            text = text.replace(/```gdscript/g, "").replace(/```/g, "").trim();

            return {
                script: text,
                explanation: "Generated with Gemini 1.5 Flash."
            };
        } catch (error) {
            console.error("[GeminiLLM] generate code Error:", error);
            return { error: "Gemini generation failed." };
        }
    }

    async debugCode(scriptContent, errorMessage) {
        try {
            const systemPrompt = `You are an expert Godot 4 Debugger.
            Analyze the following script and the error message.
            Return the FIXED script.
            Rules:
            1. Return ONLY the full fixed script.
            2. No markdown ticks.
            3. No conversational text.
            `;

            const prompt = `${systemPrompt}\n\nSCRIPT:\n${scriptContent}\n\nERROR:\n${errorMessage}`;

            const result = await this.model.generateContent(prompt);
            const response = await result.response;
            let text = response.text();

            text = text.replace(/```gdscript/g, "").replace(/```/g, "").trim();

            return {
                script: text,
                explanation: "Fixed with Gemini."
            };
        } catch (error) {
            console.error("[GeminiLLM] debug Error:", error);
            return { error: "Gemini debug failed." };
        }
    }

    async planTask(prompt) {
        try {
            // Using JSON mode or structured prompting
            const systemPrompt = `You are a Game Development Agent for Godot.
            Break down the user's request into a JSON list of steps.
            Format: { "steps": [ { "type": "asset|code|scene", "prompt": "specific instruction" } ] }
            Types:
            - 'asset': for creating textures or models (Note: Gemini cannot generate images yet, treat as placeholder).
            - 'code': for writing scripts.
            - 'scene': for building scene structures.
            
            Return ONLY valid JSON.
            `;

            // Explicitly request JSON mimetype if possible, or just strict prompting for Flash
            const result = await this.model.generateContent(systemPrompt + "\nRequest: " + prompt);
            const response = await result.response;
            let text = response.text();

            // Sanitize JSON
            text = text.replace(/```json/g, "").replace(/```/g, "").trim();
            const data = JSON.parse(text);

            return {
                steps: data.steps,
                explanation: "Plan generated by Gemini."
            };
        } catch (error) {
            console.error("[GeminiLLM] planTask Error:", error);
            return { error: "Gemini planning failed." };
        }
    }

    async generateAsset(prompt, type) {
        // Gemini Text-to-Image is not universally available in this API version yet.
        // We will return a placeholder explanation only.
        return {
            type: type,
            data: null,
            explanation: "Gemini does not support image generation yet. Please enable OpenAI for DALL-E."
        };
    }

    async generateScene(prompt) {
        try {
            const systemPrompt = `You are a Godot Scene Architect.
             Create a scene tree in JSON format based on the request.
             Format: { "tree": { "name": "RootNode", "type": "Node2D", "children": [...] } }
             Return ONLY valid JSON.
             `;

            const result = await this.model.generateContent(systemPrompt + "\nRequest: " + prompt);
            const response = await result.response;
            let text = response.text();

            text = text.replace(/```json/g, "").replace(/```/g, "").trim();
            return JSON.parse(text);

        } catch (error) {
            console.error("[GeminiLLM] generateScene Error:", error);
            return { error: "Gemini scene generation failed." };
        }
    }

    async transcribe(audioBuffer) {
        try {
            // Gemini supports audio input!
            // We need to convert buffer to base64, then construct a "Part" object.

            const audioBase64 = audioBuffer.toString('base64');

            const prompt = "Transcribe this audio precisely.";

            const result = await this.transcribeModel.generateContent([
                prompt,
                {
                    inlineData: {
                        mimeType: "audio/wav",
                        data: audioBase64
                    }
                }
            ]);

            const response = await result.response;
            const text = response.text();

            return { text: text.trim() };

        } catch (error) {
            console.error("[GeminiLLM] transcribe Error:", error);
            return { error: "Gemini transcription failed." };
        }
    }
}

module.exports = GeminiLLM;
